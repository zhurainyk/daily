>对于js来讲 ， 继承是一个难点，也是面试官常问的知识点，本文通过对继承举一些例子，侧面讲解对继承的理解认知；

+ 原型链继承 

```
    function father(){
        this.name = 'father'
        this.names = ['a','b','c']
    }
    father.prototype.getName = function(){
        return this.name;
    }

    function child = (){}

    child.prototype = new father()

    child.names.push('d')

    let child2 = new child()
    child2.names.push('d')
    console.log(child.names)  //[a,b,c,d]
    console.log(child2.names)  //[a,b,c,d]
    console.log(child.getName)  //father

    缺点：
    1.公用一个原型链，原型容易被污染（引用类型的属性被共享）
    2.创建child2时，不能向father传递参数
```

+ 借用构造函数（经典继承）

```
    function Father(name){
        this.name = name;
    }

    function Child(name){
        Father.call(this,name)
    }

    let child1 = new Child('z')
    console.log(child1.name) // z

    let child2 = new Child('x')
    console.log(child2.name) // x
    
    优点：
    1.避免引用类型的属性被共享（不会被污染 ）
    2.可以给father传递参数（call）

    缺点：
    1.每次创建实例都会创建一遍方法（调用call）

```
+ 组合继承(原型链继承+借用构造函数)
```
    function Father(name){
        this.name = name;
        this.colors = ['red','blue','yellow']
    }

    function Child(name,age){
        Pather.call(this,name)
        this.age = age
    }

    Child.prototype = new Father()
    Child.prototype.constructor = Child;

    let child1 = new Child('rainyk',18)
    child1.colors.push('green')

    console.log(child1.name,child1.age,child1.colors) // rainyk 18 [red,blue,yellow,green]

    let child2 = new Child('kevin',20)
    child2.colors.push('light')
    console.log(child1.name,child1.age,child1.colors) // kevin 20 [red,blue,yellow,light]

    优点：融合了原型链继承和构造函数的优点，是js中的常用继承模式
```